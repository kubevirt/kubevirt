name: CICD Pipeline

on:
  push:
    branches: ["ise"]
  workflow_dispatch:
  
env:
  DOCKER_PREFIX: ghcr.io/${{ github.repository }}
  DOCKER_TAG: ${{ vars.VERSION }}-l1vh.${{ github.run_number }}
  CUSTOM_LIBVIRT_IMAGE: ${{ format('ghcr.io/{0}/libvirt-rpms:{1}', github.repository, 'qemu-mshv') }}
  CUSTOM_QEMU_IMAGE: ${{ format('ghcr.io/{0}/qemu-rpms:{1}', github.repository, 'qemu-mshv') }}
  
jobs:
  quality-check:
    uses: ./.github/workflows/pr.yaml
        
  Build_Push_Images:
    runs-on: self-hosted
    needs: [quality-check]
    permissions: write-all
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Cleanup Docker containers and images
        run: |
           # Remove all running containers
           docker ps -q | xargs -r docker rm -f
           # Remove stopped containers, unused images, networks, and optionally volumes
           docker system prune -f

      - name: Login to GHCR
        uses: docker/login-action@v1 
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}


      - name: Setup Custom libvirt & qemu RPMs
        run: |
          set -euo pipefail
          echo "Setting up custom libvirt & qemu RPM repos..."

          # Pull pre-built RPM images
          docker pull ${{ env.CUSTOM_LIBVIRT_IMAGE }}
          docker pull ${{ env.CUSTOM_QEMU_IMAGE }}
          
          # Start libvirt repo HTTP server (port 8080) if not running
          if [ "$(docker ps -q -f name=libvirt-rpms-http-server)" ]; then
            echo "Libvirt RPM server already running"
          else
            docker run --rm -dit \
              --name libvirt-rpms-http-server \
              -p 8080:80 \
              ${{ env.CUSTOM_LIBVIRT_IMAGE }}
            sleep 5
          fi          


          # Start qemu repo HTTP server (port 9090) if not running
            if [ "$(docker ps -q -f name=qemu-rpms-http-server)" ]; then
            echo "QEMU RPM server already running"
          else
            docker run --rm -dit \
              --name qemu-rpms-http-server \
              -p 9090:80 \
              ${{ env.CUSTOM_QEMU_IMAGE }}
            sleep 5
          fi

          LIBVIRT_IP=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' libvirt-rpms-http-server)
          QEMU_IP=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' qemu-rpms-http-server)
          echo "Libvirt repo IP: $LIBVIRT_IP"
          echo "QEMU repo IP:    $QEMU_IP"

          # Verify both repos (use their mapped host ports)
          curl -f "http://localhost:8080/x86_64/repodata/repomd.xml" || { echo 'Libvirt repo not accessible'; exit 1; }
          curl -f "http://localhost:9090/x86_64/repodata/repomd.xml" || { echo 'QEMU repo not accessible'; exit 1; }

          # Extract versions (tolerate missing build-info fields)
          LIBVIRT_VERSION=$(curl -s "http://localhost:8080/build-info.json" | jq -r '.libvirt_version // empty') || true
          QEMU_VERSION=$(curl -s "http://localhost:9090/build-info.json" | jq -r '.qemu_version // empty') || true
          echo "Detected libvirt version: ${LIBVIRT_VERSION:-<none>}"
          echo "Detected qemu version:    ${QEMU_VERSION:-<none>}"


          # Build combined repo descriptor so rpm-deps sees both
          cat > custom-repo.yaml <<EOF
          repositories:
          - arch: x86_64
            baseurl: http://$LIBVIRT_IP:80/x86_64/
            name: custom-libvirt
            gpgcheck: 0
            repo_gpgcheck: 0
          - arch: x86_64
            baseurl: http://$QEMU_IP:80/x86_64/
            name: custom-qemu
            gpgcheck: 0
            repo_gpgcheck: 0
          EOF

          echo "Combined custom-repo.yaml:"; cat custom-repo.yaml

          make CUSTOM_REPO=custom-repo.yaml LIBVIRT_VERSION="$LIBVIRT_VERSION" QEMU_VERSION="$QEMU_VERSION" SINGLE_ARCH="x86_64" rpm-deps

          echo "rpm-deps completed with custom libvirt & qemu"
          

      - name: Build Images
        run: |
          make bazel-build-images 

      - name: Push Images
        run: |
          make bazel-push-images

      - name: Cleanup Custom RPM Servers
        if: always()
        run: |
          docker rm -f libvirt-rpms-http-server 2>/dev/null || true
          docker rm -f qemu-rpms-http-server 2>/dev/null || true
          echo "Custom RPM HTTP servers cleaned up"


  
  dev:
    uses: ./.github/workflows/deploy.yaml
    with:
      environment: dev
      image_tag: ${{ vars.VERSION }}-l1vh.${{ github.run_number }}
    secrets: inherit
    needs: [Build_Push_Images]

  test-kvm:
    uses: ./.github/workflows/deploy.yaml
    with:
      environment: test-kvm
      image_tag: ${{ vars.VERSION }}-l1vh.${{ github.run_number }}
    secrets: inherit
    needs: [dev]

  test-emulation:
    uses: ./.github/workflows/deploy.yaml
    with:
      environment: test-emulation
      image_tag: ${{ vars.VERSION }}-l1vh.${{ github.run_number }}
    secrets: inherit
    needs: [dev]

  test-mshv:
    uses: ./.github/workflows/deploy.yaml
    with:
      environment: test-mshv
      image_tag: ${{ vars.VERSION }}-l1vh.${{ github.run_number }}
    secrets: inherit
    needs: [dev]