// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/operator-framework/operator-lifecycle-manager/pkg/api/apis/operators/v1alpha1"
	"github.com/operator-framework/operator-lifecycle-manager/pkg/controller/install"
	"github.com/operator-framework/operator-lifecycle-manager/pkg/lib/operatorclient"
	"github.com/operator-framework/operator-lifecycle-manager/pkg/lib/ownerutil"
)

type FakeStrategyResolverInterface struct {
	UnmarshalStrategyStub        func(s v1alpha1.NamedInstallStrategy) (strategy install.Strategy, err error)
	unmarshalStrategyMutex       sync.RWMutex
	unmarshalStrategyArgsForCall []struct {
		s v1alpha1.NamedInstallStrategy
	}
	unmarshalStrategyReturns struct {
		result1 install.Strategy
		result2 error
	}
	unmarshalStrategyReturnsOnCall map[int]struct {
		result1 install.Strategy
		result2 error
	}
	InstallerForStrategyStub        func(strategyName string, opClient operatorclient.ClientInterface, owner ownerutil.Owner, previousStrategy install.Strategy) install.StrategyInstaller
	installerForStrategyMutex       sync.RWMutex
	installerForStrategyArgsForCall []struct {
		strategyName     string
		opClient         operatorclient.ClientInterface
		owner            ownerutil.Owner
		previousStrategy install.Strategy
	}
	installerForStrategyReturns struct {
		result1 install.StrategyInstaller
	}
	installerForStrategyReturnsOnCall map[int]struct {
		result1 install.StrategyInstaller
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStrategyResolverInterface) UnmarshalStrategy(s v1alpha1.NamedInstallStrategy) (strategy install.Strategy, err error) {
	fake.unmarshalStrategyMutex.Lock()
	ret, specificReturn := fake.unmarshalStrategyReturnsOnCall[len(fake.unmarshalStrategyArgsForCall)]
	fake.unmarshalStrategyArgsForCall = append(fake.unmarshalStrategyArgsForCall, struct {
		s v1alpha1.NamedInstallStrategy
	}{s})
	fake.recordInvocation("UnmarshalStrategy", []interface{}{s})
	fake.unmarshalStrategyMutex.Unlock()
	if fake.UnmarshalStrategyStub != nil {
		return fake.UnmarshalStrategyStub(s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unmarshalStrategyReturns.result1, fake.unmarshalStrategyReturns.result2
}

func (fake *FakeStrategyResolverInterface) UnmarshalStrategyCallCount() int {
	fake.unmarshalStrategyMutex.RLock()
	defer fake.unmarshalStrategyMutex.RUnlock()
	return len(fake.unmarshalStrategyArgsForCall)
}

func (fake *FakeStrategyResolverInterface) UnmarshalStrategyArgsForCall(i int) v1alpha1.NamedInstallStrategy {
	fake.unmarshalStrategyMutex.RLock()
	defer fake.unmarshalStrategyMutex.RUnlock()
	return fake.unmarshalStrategyArgsForCall[i].s
}

func (fake *FakeStrategyResolverInterface) UnmarshalStrategyReturns(result1 install.Strategy, result2 error) {
	fake.UnmarshalStrategyStub = nil
	fake.unmarshalStrategyReturns = struct {
		result1 install.Strategy
		result2 error
	}{result1, result2}
}

func (fake *FakeStrategyResolverInterface) UnmarshalStrategyReturnsOnCall(i int, result1 install.Strategy, result2 error) {
	fake.UnmarshalStrategyStub = nil
	if fake.unmarshalStrategyReturnsOnCall == nil {
		fake.unmarshalStrategyReturnsOnCall = make(map[int]struct {
			result1 install.Strategy
			result2 error
		})
	}
	fake.unmarshalStrategyReturnsOnCall[i] = struct {
		result1 install.Strategy
		result2 error
	}{result1, result2}
}

func (fake *FakeStrategyResolverInterface) InstallerForStrategy(strategyName string, opClient operatorclient.ClientInterface, owner ownerutil.Owner, previousStrategy install.Strategy) install.StrategyInstaller {
	fake.installerForStrategyMutex.Lock()
	ret, specificReturn := fake.installerForStrategyReturnsOnCall[len(fake.installerForStrategyArgsForCall)]
	fake.installerForStrategyArgsForCall = append(fake.installerForStrategyArgsForCall, struct {
		strategyName     string
		opClient         operatorclient.ClientInterface
		owner            ownerutil.Owner
		previousStrategy install.Strategy
	}{strategyName, opClient, owner, previousStrategy})
	fake.recordInvocation("InstallerForStrategy", []interface{}{strategyName, opClient, owner, previousStrategy})
	fake.installerForStrategyMutex.Unlock()
	if fake.InstallerForStrategyStub != nil {
		return fake.InstallerForStrategyStub(strategyName, opClient, owner, previousStrategy)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.installerForStrategyReturns.result1
}

func (fake *FakeStrategyResolverInterface) InstallerForStrategyCallCount() int {
	fake.installerForStrategyMutex.RLock()
	defer fake.installerForStrategyMutex.RUnlock()
	return len(fake.installerForStrategyArgsForCall)
}

func (fake *FakeStrategyResolverInterface) InstallerForStrategyArgsForCall(i int) (string, operatorclient.ClientInterface, ownerutil.Owner, install.Strategy) {
	fake.installerForStrategyMutex.RLock()
	defer fake.installerForStrategyMutex.RUnlock()
	return fake.installerForStrategyArgsForCall[i].strategyName, fake.installerForStrategyArgsForCall[i].opClient, fake.installerForStrategyArgsForCall[i].owner, fake.installerForStrategyArgsForCall[i].previousStrategy
}

func (fake *FakeStrategyResolverInterface) InstallerForStrategyReturns(result1 install.StrategyInstaller) {
	fake.InstallerForStrategyStub = nil
	fake.installerForStrategyReturns = struct {
		result1 install.StrategyInstaller
	}{result1}
}

func (fake *FakeStrategyResolverInterface) InstallerForStrategyReturnsOnCall(i int, result1 install.StrategyInstaller) {
	fake.InstallerForStrategyStub = nil
	if fake.installerForStrategyReturnsOnCall == nil {
		fake.installerForStrategyReturnsOnCall = make(map[int]struct {
			result1 install.StrategyInstaller
		})
	}
	fake.installerForStrategyReturnsOnCall[i] = struct {
		result1 install.StrategyInstaller
	}{result1}
}

func (fake *FakeStrategyResolverInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.unmarshalStrategyMutex.RLock()
	defer fake.unmarshalStrategyMutex.RUnlock()
	fake.installerForStrategyMutex.RLock()
	defer fake.installerForStrategyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStrategyResolverInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ install.StrategyResolverInterface = new(FakeStrategyResolverInterface)
