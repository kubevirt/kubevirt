package backendstorage_test

import (
	"strings"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gstruct"
	k8sv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/tools/cache"
	"k8s.io/utils/pointer"
	v1 "kubevirt.io/api/core/v1"
	"kubevirt.io/client-go/api"

	"kubevirt.io/kubevirt/tests/libvmi"

	backendstorage "kubevirt.io/kubevirt/pkg/storage/backend-storage"
	"kubevirt.io/kubevirt/pkg/testutils"
	"kubevirt.io/kubevirt/tests"
	"kubevirt.io/kubevirt/tests/libstorage"
)

var _ = Describe("Determine the storage class and volume mode", func() {
	filesystemStorageClass := "filesystem-storage"
	blockStorageClass := "block-storage"
	filesystemVolumeMode := k8sv1.PersistentVolumeFilesystem
	blockVolumeMode := k8sv1.PersistentVolumeBlock
	filesystemDVName := "fs-dv"
	blockPVCName := "block-pvc"

	// filesystemPVC is the PVC generated by the filesystem DV.
	filesystemPVC := &k8sv1.PersistentVolumeClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name: filesystemDVName,
		},
		Spec: k8sv1.PersistentVolumeClaimSpec{
			StorageClassName: &filesystemStorageClass,
			VolumeMode:       &filesystemVolumeMode,
		},
	}
	blockPVC := &k8sv1.PersistentVolumeClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name: blockPVCName,
		},
		Spec: k8sv1.PersistentVolumeClaimSpec{
			StorageClassName: &blockStorageClass,
			VolumeMode:       &blockVolumeMode,
		},
	}
	pvcStore := &cache.FakeCustomStore{
		GetByKeyFunc: func(key string) (item interface{}, exists bool, err error) {
			if strings.Contains(key, filesystemDVName) {
				return filesystemPVC, true, nil
			}
			if strings.Contains(key, blockPVCName) {
				return blockPVC, true, nil
			}
			return nil, false, nil
		},
	}

	It("should correctly find them from kubevirt config and VM with container disk", func() {
		vmi := api.NewMinimalVMI("vm-1")
		tests.AddEphemeralDisk(vmi, "disk0", v1.DiskBusVirtio, "fedora")
		addBootOrderToDisk(vmi, "disk0", pointer.Uint(1))
		clusterConfig, _, _ := testutils.NewFakeClusterConfigUsingKVConfig(&v1.KubeVirtConfiguration{
			VMStateStorageClass: blockStorageClass,
			VMStateVolumeMode:   &blockVolumeMode,
		})
		s, v, err := backendstorage.DetermineStorageClassAndVolumeMode(vmi, clusterConfig, pvcStore)
		Expect(s).To(gstruct.PointTo(Equal(blockStorageClass)))
		Expect(v).To(gstruct.PointTo(Equal(k8sv1.PersistentVolumeBlock)))
		Expect(err).ToNot(HaveOccurred())
	})

	It("should correctly find them from kubevirt config and VM with a block disk and a filesystem disk with smaller boot order", func() {
		vmi := api.NewMinimalVMI("vm-1")
		libvmi.WithPersistentVolumeClaim("disk0", blockPVCName)(vmi)
		libstorage.AddDataVolumeDisk(vmi, "disk1", filesystemDVName)
		addBootOrderToDisk(vmi, "disk1", pointer.Uint(1))
		Expect(vmi.Spec.Domain.Devices.Disks[0].Name).To(Equal("disk0"))
		clusterConfig, _, _ := testutils.NewFakeClusterConfigUsingKVConfig(&v1.KubeVirtConfiguration{
			VMStateStorageClass: blockStorageClass,
			VMStateVolumeMode:   nil,
		})
		s, v, err := backendstorage.DetermineStorageClassAndVolumeMode(vmi, clusterConfig, pvcStore)
		Expect(s).To(gstruct.PointTo(Equal(blockStorageClass)))
		Expect(v).To(BeNil())
		Expect(err).ToNot(HaveOccurred())
	})

	It("should correctly find them from VM with a block disk and a filesystem disk with smaller boot order", func() {
		vmi := api.NewMinimalVMI("vm-1")
		libvmi.WithPersistentVolumeClaim("disk0", blockPVCName)(vmi)
		libstorage.AddDataVolumeDisk(vmi, "disk1", filesystemDVName)
		addBootOrderToDisk(vmi, "disk1", pointer.Uint(1))
		Expect(vmi.Spec.Domain.Devices.Disks[0].Name).To(Equal("disk0"))
		clusterConfig, _, _ := testutils.NewFakeClusterConfigUsingKVConfig(&v1.KubeVirtConfiguration{
			VMStateStorageClass: "",
			VMStateVolumeMode:   nil,
		})
		s, v, err := backendstorage.DetermineStorageClassAndVolumeMode(vmi, clusterConfig, pvcStore)
		Expect(s).To(gstruct.PointTo(Equal(filesystemStorageClass)))
		Expect(v).To(gstruct.PointTo(Equal(k8sv1.PersistentVolumeFilesystem)))
		Expect(err).ToNot(HaveOccurred())
	})

	It("should correctly find them from VM with a block disk and a filesystem disk", func() {
		vmi := api.NewMinimalVMI("vm-1")
		libvmi.WithPersistentVolumeClaim("disk0", blockPVCName)(vmi)
		libstorage.AddDataVolumeDisk(vmi, "disk1", filesystemDVName)
		Expect(vmi.Spec.Domain.Devices.Disks[0].Name).To(Equal("disk0"))
		clusterConfig, _, _ := testutils.NewFakeClusterConfigUsingKVConfig(&v1.KubeVirtConfiguration{
			VMStateStorageClass: "",
			VMStateVolumeMode:   nil,
		})
		s, v, err := backendstorage.DetermineStorageClassAndVolumeMode(vmi, clusterConfig, pvcStore)
		Expect(s).To(gstruct.PointTo(Equal(blockStorageClass)))
		Expect(v).To(gstruct.PointTo(Equal(k8sv1.PersistentVolumeBlock)))
		Expect(err).ToNot(HaveOccurred())
	})
})

func addBootOrderToDisk(vmi *v1.VirtualMachineInstance, diskName string, bootorder *uint) *v1.VirtualMachineInstance {
	for i, d := range vmi.Spec.Domain.Devices.Disks {
		if d.Name == diskName {
			vmi.Spec.Domain.Devices.Disks[i].BootOrder = bootorder
			return vmi
		}
	}
	return vmi
}
